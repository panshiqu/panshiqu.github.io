---
layout: default
---

# RabbitMQ SDK 支持发布、消费，连接恢复，死信队列，多种使用场景
_2024-06-24 10:00:00_

* * *

基于[Example](https://github.com/rabbitmq/amqp091-go/blob/main/_examples/client/client.go)封装便于使用的[SDK](https://github.com/panshiqu/golang/tree/main/rabbitmq)，支持发布、消费，连接恢复，[死信队列](https://www.rabbitmq.com/docs/dlx)，以及官方入门中的多种使用场景

### 参数解释（测试代码在下面）
* 直接使用`amq.topic`，仅是出于逻辑简单代码少，若想数据隔离，可声明自定义主题类型交换（ExchangeDeclare）并使用
* 建议生产消费者尽量对称提供`queueName`和`keys`，确保发布消费前完成声明绑定逻辑。`queueName`用来声明名称是`queueName`、`queueName_dead_letter`（死信）的队列，绑定`queueName`到`amq.topic`，并使用所有的`keys`充当路由键
* 若队列已声明且绑定路由已建立，未来消费者启动仅需提供`queueName`表明从此队列消费，未来生产者启动仅需提供`key`用做发布路由键，但`queueName`会因为空而使用默认值`default_queue_name`来触发总是执行的声明队列（QueueDeclare）逻辑，来避免意外声明RabbitMQ随机命名的队列
* 使用手动[消息确认](https://www.rabbitmq.com/tutorials/tutorial-two-go#message-acknowledgment)，队列和消息标记为[持久](https://www.rabbitmq.com/tutorials/tutorial-two-go#message-durability)，并不使用临时[独占](https://www.rabbitmq.com/tutorials/tutorial-three-go#temporary-queues)队列
* 消费者可合理调大`Qos.prefetchCount`来提高吞吐率

### 启动RabbitMQ
```bash
docker run -d -p 15672:15672 -p 5672:5672 --hostname rabbitmq --name rabbitmq -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest rabbitmq:3-management
```

